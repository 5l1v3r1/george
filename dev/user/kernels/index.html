

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kernels &mdash; George 1.0.0.dev0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="George 1.0.0.dev0 documentation" href="../../"/>
        <link rel="next" title="Modeling protocol" href="../modeling/"/>
        <link rel="prev" title="The GP object" href="../gp/"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../" class="fa fa-home"> George</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/quickstart/">Getting started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/quickstart/#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/quickstart/#a-simple-example">A Simple Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/model/">Tutorial: model fitting with correlated noise</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/model/#a-simple-mean-model">A Simple Mean Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/model/#simulated-dataset">Simulated Dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/model/#assuming-white-noise">Assuming White Noise</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/model/#modeling-the-noise">Modeling the Noise</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/model/#the-final-fit">The Final Fit</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/hyper/">Tutorial: hyperparameter optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/hyper/#optimization">Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials/hyper/#sampling-marginalization">Sampling &amp; Marginalization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/new_kernel/">Implementing a new kernel function</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gp/">The GP object</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Kernels</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#common-parameters">Common parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-details-modeling-interface">Implementation details &amp; modeling interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stationary-kernels">Stationary kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#non-stationary-kernels">Non-stationary kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combining-kernels">Combining kernels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-new-kernels">Implementing new kernels</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modeling/">Modeling protocol</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modeling/#the-protocol">The protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modeling/#a-simple-example">A simple example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../solvers/">Solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../solvers/#basic-solver">Basic Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../solvers/#hodlr-solver">HODLR Solver</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../">George</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../">Docs</a> &raquo;</li>
      
    <li>Kernels</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="https://github.com/dfm/george/blob/master/docs/user/kernels.rst" class="fa fa-github"> Edit on GitHub</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <span class="target" id="module-george.kernels"></span><div class="section" id="kernels">
<span id="id1"></span><h1>Kernels<a class="headerlink" href="#kernels" title="Permalink to this headline">¶</a></h1>
<p>George comes equipped with a suite of standard covariance functions or
kernels that can be combined to build more complex models.
The standard kernels fall into the following categories:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#stationary-kernels"><em>Stationary kernels</em></a> — functions that depend only on the radial
distance between points in some user-defined metric, and</li>
<li><a class="reference internal" href="#non-stationary-kernels"><em>Non-stationary kernels</em></a> — functions that depend on the value of the
input coordinates themselves.</li>
</ol>
<p><a class="reference internal" href="#combining-kernels"><em>Combining kernels</em></a> describes how to combine kernels to build more
sophisticated models and <a class="reference internal" href="#new-kernels"><em>Implementing new kernels</em></a> explains how you would go about
incorporating a custom kernel.</p>
<div class="section" id="common-parameters">
<h2>Common parameters<a class="headerlink" href="#common-parameters" title="Permalink to this headline">¶</a></h2>
<p>Every kernel accepts the two keyword arguments <tt class="docutils literal"><span class="pre">ndim</span></tt> and <tt class="docutils literal"><span class="pre">axes</span></tt>. By
default, kernels are only one dimensional so you must specify the <tt class="docutils literal"><span class="pre">ndim</span></tt>
argument if you want the kernel to work with higher dimensional inputs.
By default, higher dimensional kernels are applied to every dimension but you
can restrict the evaluation to a subspace using the <tt class="docutils literal"><span class="pre">axes</span></tt> argument.
For example, if you have a 3 dimensional input space but you want one of the
kernels to only act in the first dimension, you would do the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">george</span> <span class="kn">import</span> <span class="n">kernels</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">Matern32Kernel</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, if you wanted the kernel to act on only the second and third
dimensions, you could do something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">kernel</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">ExpSquaredKernel</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="implementation-details-modeling-interface">
<span id="implementation"></span><h2>Implementation details &amp; modeling interface<a class="headerlink" href="#implementation-details-modeling-interface" title="Permalink to this headline">¶</a></h2>
<p>It&#8217;s worth understanding how these kernels are implemented.
Most of the hard work is done at a low level (in C++) and the Python is only a
thin wrapper to this functionality.
This makes the code fast and consistent across interfaces but it also means
that it isn&#8217;t currently possible to implement new kernel functions without
recompiling the code.
Almost every kernel has hyperparameters that you can set to control its
behavior and these are controlled using the <a class="reference internal" href="../modeling/#modeling"><em>Modeling protocol</em></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">Matern32Kernel</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_parameter_names</span><span class="p">())</span>
<span class="c"># [&#39;k1:ln_constant&#39;, &#39;k2:ln_M_0_0&#39;]</span>

<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 0.69314718  1.60943791]</span>
</pre></div>
</div>
<p>You&#8217;ll notice that, in this case, the parameter vector is the logarithm of
the parameters given when building the kernel.
This will be the case for any strictly positive parameters because it is
always better to fit in the logarithm of these types of parameters.
You probably also noticed that the parameters have names.
This opens up a few interesting features.
For example, if you want to change any of the parameters, you can do it as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">k</span><span class="p">[</span><span class="s">&quot;k1:ln_constant&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 2.30258509  1.60943791]</span>

<span class="c"># ... or:</span>
<span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 0.69314718  1.60943791]</span>
</pre></div>
</div>
<p>Finally, if you want to update the entire vector, you can use the
<tt class="xref py py-func docutils literal"><span class="pre">set_vector()</span></tt> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span><span class="o">.</span><span class="n">set_vector</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Another feature common to the kernels is that you can &#8220;freeze&#8221; and &#8220;thaw&#8221;
parameters by name.
For example, let&#8217;s say that you want to keep the amplitude of your kernel
fixed and fit for only the scale length:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">Matern32Kernel</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
<span class="n">k</span><span class="o">.</span><span class="n">freeze_parameter</span><span class="p">(</span><span class="s">&quot;k1:ln_constant&quot;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_parameter_names</span><span class="p">())</span>
<span class="c"># [&#39;k2:ln_M_0_0&#39;]</span>

<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 1.60943791]</span>
</pre></div>
</div>
<p>Bringing a parameter back into the fold is as easy as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span><span class="o">.</span><span class="n">thaw_parameter</span><span class="p">(</span><span class="s">&quot;k1:ln_constant&quot;</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_parameter_names</span><span class="p">())</span>
<span class="c"># [&#39;k1:ln_constant&#39;, &#39;k2:ln_M_0_0&#39;]</span>

<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 0.69314718  1.60943791]</span>
</pre></div>
</div>
</div>
<div class="section" id="stationary-kernels">
<span id="id2"></span><h2>Stationary kernels<a class="headerlink" href="#stationary-kernels" title="Permalink to this headline">¶</a></h2>
<p>Stationary kernels are a class of functions that depend on the input
coordinates <span class="math">\(\mathbf{x}_i\)</span> and <span class="math">\(\mathbf{x}_j\)</span> through their
squared distance under some metric <span class="math">\(C\)</span>:</p>
<div class="math">
\[r^2 = (\mathbf{x}_i - \mathbf{x}_j)^\mathrm{T}\,C^{-1}\,
    (\mathbf{x}_i - \mathbf{x}_j)\]</div>
<p>The currently supported metrics are:</p>
<ol class="arabic simple">
<li>&#8220;isotropic&#8221; — the scale length is equal in all dimensions,</li>
<li>&#8220;axis-aligned&#8221; — there is a different scale length in each dimension, and</li>
<li>&#8220;general&#8221; — arbitrary covariances between dimensions are allowed.</li>
</ol>
<p>The &#8220;isotropic&#8221; and &#8220;axis-aligned&#8221; metrics are parameterized by the logarithms
of their scale lengths.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">george.metrics</span> <span class="kn">import</span> <span class="n">Metric</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 0.69314718]</span>
</pre></div>
</div>
<p>gives a two-dimensional isotropic metric with</p>
<div class="math">
\[\begin{split}C = \left(\begin{array}{cc} 2 &amp; 0 \\ 0 &amp; 2 \end{array}\right)\end{split}\]</div>
<p>and</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">],</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 0.69314718  1.38629436]</span>
</pre></div>
</div>
<p>specifies the following matrix</p>
<div class="math">
\[\begin{split}C = \left(\begin{array}{cc} 2 &amp; 0 \\ 0 &amp; 4 \end{array}\right) \quad.\end{split}\]</div>
<p>In the &#8220;general&#8221; case, the matrix is parameterized by the elements of the
Cholesky decomposition <span class="math">\(C = L\,L^\mathrm{T}\)</span> with logarithms along the
diagonal.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">Metric</span><span class="p">([[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 0.34657359  0.07071068  0.69252179]</span>
</pre></div>
</div>
<p>All the stationary kernels take the <tt class="docutils literal"><span class="pre">metric</span></tt> specification as a keyword
argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span> <span class="o">=</span> <span class="n">kernels</span><span class="o">.</span><span class="n">ExpSquaredKernel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="p">[[</span><span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">get_vector</span><span class="p">())</span>
<span class="c"># [ 0.80471896  0.04472136  0.69289712]</span>
</pre></div>
</div>
<p>The currently available stationary kernels are:</p>
<dl class="class">
<dt id="george.kernels.ExpSquaredKernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">ExpSquaredKernel</tt><big>(</big><em>metric=None</em>, <em>lower=True</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.ExpSquaredKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential-squared kernel is a stationary kernel where the value
at a given radius <span class="math">\(r^2\)</span> is given by:</p>
<div class="math">
\[k(r^2) = \exp \left ( -\frac{r^2}{2} \right )\]</div>
</dd></dl>

<dl class="class">
<dt id="george.kernels.Matern32Kernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">Matern32Kernel</tt><big>(</big><em>metric=None</em>, <em>lower=True</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.Matern32Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The Matern-3/2 kernel is stationary kernel where the value at a
given radius <span class="math">\(r^2\)</span> is given by:</p>
<div class="math">
\[k(r^2) = \left( 1+\sqrt{3\,r^2} \right)\,
         \exp \left (-\sqrt{3\,r^2} \right )\]</div>
</dd></dl>

<dl class="class">
<dt id="george.kernels.Matern52Kernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">Matern52Kernel</tt><big>(</big><em>metric=None</em>, <em>lower=True</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.Matern52Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The Matern-5/2 kernel is stationary kernel where the value at a
given radius <span class="math">\(r^2\)</span> is given by:</p>
<div class="math">
\[k(r^2) = \left( 1+\sqrt{5\,r^2}+ \frac{5\,r^2}{3} \right)\,
         \exp \left (-\sqrt{5\,r^2} \right )\]</div>
</dd></dl>

<dl class="class">
<dt id="george.kernels.ExpKernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">ExpKernel</tt><big>(</big><em>metric=None</em>, <em>lower=True</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.ExpKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The exponential-squared kernel is a stationary kernel where the value
at a given radius <span class="math">\(r^2\)</span> is given by:</p>
<div class="math">
\[k(r^2) = \exp \left ( -\sqrt{r^2} \right )\]</div>
</dd></dl>

<dl class="class">
<dt id="george.kernels.RationalQuadraticKernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">RationalQuadraticKernel</tt><big>(</big><em>ln_alpha=None</em>, <em>alpha=None</em>, <em>metric=None</em>, <em>lower=True</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.RationalQuadraticKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>This is equivalent to a &#8220;scale mixture&#8221; of <a class="reference internal" href="#george.kernels.ExpSquaredKernel" title="george.kernels.ExpSquaredKernel"><tt class="xref py py-class docutils literal"><span class="pre">ExpSquaredKernel</span></tt></a>
kernels with different scale lengths drawn from a gamma distribution.
See R&amp;W for more info but here&#8217;s the equation:</p>
<div class="math">
\[k(r^2) = \left[1 - \frac{r^2}{2\,\alpha} \right]^\alpha\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>alpha</strong> &#8211; The Gamma distribution parameter.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="non-stationary-kernels">
<span id="id3"></span><h2>Non-stationary kernels<a class="headerlink" href="#non-stationary-kernels" title="Permalink to this headline">¶</a></h2>
<p>Non-stationary kernels are specified by a (symmetric) function of the input
coordinates themselves.
They are applied identically to every axis so the <tt class="docutils literal"><span class="pre">axes</span></tt> keyword argument
will probably come in handy.</p>
<p>For example, to implement a quasi-periodic kernel with a three-dimensional
input space where you only want to apply the periodicity along the first
(e.g. time) dimension, you would use something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k</span> <span class="o">=</span> <span class="n">kernels</span><span class="o">.</span><span class="n">ExpSine2Kernel</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">k</span> <span class="o">*=</span> <span class="mf">10.0</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">ExpSquaredKernel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">k</span> <span class="o">+=</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">Matern32Kernel</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>The currently available non-stationary kernels are:</p>
<dl class="class">
<dt id="george.kernels.ConstantKernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">ConstantKernel</tt><big>(</big><em>ln_constant=None</em>, <em>constant=None</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.ConstantKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>This kernel returns the constant</p>
<div class="math">
\[k(\mathbf{x}_i,\,\mathbf{x}_j) = c\]</div>
<p>where <span class="math">\(c\)</span> is a parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>constant</strong> &#8211; The constant value <span class="math">\(c\)</span> in the above equation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="george.kernels.DotProductKernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">DotProductKernel</tt><big>(</big><em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.DotProductKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The linear regression kernel</p>
<div class="math">
\[k(\mathbf{x}_i,\,\mathbf{x}_j) = \mathbf{x}_i \cdot \mathbf{x}_j\]</div>
<p>with no parameters.</p>
</dd></dl>

<dl class="class">
<dt id="george.kernels.CosineKernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">CosineKernel</tt><big>(</big><em>ln_period=None</em>, <em>period=None</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.CosineKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The simplest periodic kernel. This</p>
<div class="math">
\[k(\mathbf{x}_i,\,\mathbf{x}_j) = \cos\left(
    \frac{2\,\pi\,|x_i - x_j|}{P} \right)\]</div>
<p>where the parameter <span class="math">\(P\)</span> is the period of the oscillation. This
kernel should probably always be multiplied be a stationary kernel
(e.g. <a class="reference internal" href="#george.kernels.ExpSquaredKernel" title="george.kernels.ExpSquaredKernel"><tt class="xref py py-class docutils literal"><span class="pre">ExpSquaredKernel</span></tt></a>) to allow quasi-periodic variations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>period</strong> &#8211; The period of the oscillation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="george.kernels.ExpSine2Kernel">
<em class="property">class </em><tt class="descclassname">george.kernels.</tt><tt class="descname">ExpSine2Kernel</tt><big>(</big><em>gamma=None</em>, <em>ln_period=None</em>, <em>period=None</em>, <em>ndim=1</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#george.kernels.ExpSine2Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The exp-sine-squared kernel is a commonly used periodic kernel. Unlike
the <a class="reference internal" href="#george.kernels.CosineKernel" title="george.kernels.CosineKernel"><tt class="xref py py-class docutils literal"><span class="pre">CosineKernel</span></tt></a>, this kernel never has negative covariance
which might be useful for your problem. Here&#8217;s the equation:</p>
<div class="math">
\[k(\mathbf{x}_i,\,\mathbf{x}_j) =
    \exp \left( -\Gamma\,\sin^2\left[
        \frac{\pi}{P}\,\left|x_i-x_j\right|
    \right] \right)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>gamma</strong> &#8211; The scale <span class="math">\(\Gamma\)</span> of the correlations.</li>
<li><strong>period</strong> &#8211; The period <span class="math">\(P\)</span> of the oscillation (in the same units as
<span class="math">\(\mathbf{x}\)</span>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="combining-kernels">
<span id="id4"></span><h2>Combining kernels<a class="headerlink" href="#combining-kernels" title="Permalink to this headline">¶</a></h2>
<p>More complicated kernels can be constructed by algebraically combining the
basic kernels listed in the previous sections.
In particular, all the kernels support addition and multiplication.
For example, an exponential-squared kernel with a non-trivial variance can be
constructed as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">george</span> <span class="kn">import</span> <span class="n">kernels</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">ExpSquaredKernel</span><span class="p">(</span><span class="mf">3.4</span><span class="p">)</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">kernels</span><span class="o">.</span><span class="n">Product</span><span class="p">(</span><span class="n">kernels</span><span class="o">.</span><span class="n">ConstantKernel</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1e-3</span><span class="p">)),</span>
                         <span class="n">kernels</span><span class="o">.</span><span class="n">ExpSquaredKernel</span><span class="p">(</span><span class="mf">3.4</span><span class="p">))</span>
</pre></div>
</div>
<p>As demonstrated in <em class="xref std std-ref">hyper</em>, a mixture of kernels can be implemented with
addition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">k1</span> <span class="o">=</span> <span class="mf">1e-3</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">ExpSquaredKernel</span><span class="p">(</span><span class="mf">3.4</span><span class="p">)</span>
<span class="n">k2</span> <span class="o">=</span> <span class="mf">1e-4</span> <span class="o">*</span> <span class="n">kernels</span><span class="o">.</span><span class="n">Matern32Kernel</span><span class="p">(</span><span class="mf">14.53</span><span class="p">)</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-new-kernels">
<span id="new-kernels"></span><h2>Implementing new kernels<a class="headerlink" href="#implementing-new-kernels" title="Permalink to this headline">¶</a></h2>
<p>As mentioned previously, because of technical limitations, new kernels can
only be implemented by re-compiling george.
See</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../modeling/" class="btn btn-neutral float-right" title="Modeling protocol"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../gp/" class="btn btn-neutral" title="The GP object"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013-2014 Dan Foreman-Mackey.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0.0.dev0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script type="text/javascript" src="../../_static/js/analytics.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>